= ここがクソだよ暗号資産

== はじめに

はじめましての方ははじめまして。
お久しぶりの方はお久しぶりです。るなすたです。

今回は、bitcoin とそこからフォークした monacoin など各種アルトコインの
仕様である、P2SH の実装がいかに酷いか、語りたいと思います。

今回も、基礎的なところから順に説明していきますので、
頑張ってついてきていただければ幸いです。

== 前提知識

=== 暗号資産におけるトランザクションとは

トランザクション、日本語で言えば取引と訳されるところですが、
暗号資産においても、概ね間違った訳ではありません。

ですが、技術的に見ていくともう少し異なった側面が見えてきます。
まずはそこからお話していきましょう。

ここからは代表して bitcoin について語りますが、
bitcoin とそこからフォークした各種アルトコイン、すべてが対象となる話ですので、
その旨了承していただければと思います。

bitcoin では、資産の価値というものの、所有権（今はまだふわっとしていますが、
後できちんと定義します）を次々と移転していくその経緯をすべて、
データベースとして共有管理しています。

つまり、bitcoin が実際に持っている情報は、資産の価値の移転の記録であり、
その構成要素となる最小単位が、トランザクションと呼ばれるものです。

トランザクションには、入力と出力と呼ばれるものがあり、
別のトランザクションを接続するための口、ポートとして機能しています。

あるトランザクションの出力から別のトランザクションの入力に接続する、
この接続によってトランザクションの集合は網目のようにつながっており、
資産の価値の流れを示しています。
これらすべてが、bitcoin の管理する資産の価値の移転情報というわけです。
そして、その 1 単位がトランザクションという位置づけになっています。

また、トランザクションは、複数の入力、複数の出力を持ちます。
複数のトランザクションの出力から資産の価値を束ね、
複数のトランザクションに対して送り出すことができるようになっています。

これにより、何人かから集めた資産を束ね、一部を誰かに送金し、残りを自分に送金する、
つまりおつりとして使うことができるわけです。

新規のトランザクションを作成し、他のトランザクションの出力から
新しいトランザクションの入力に接続する。そして、送金先の人が使うための、
もしくは自分が使うための出力を定義する。
これが、bitcoin における送金の仕組みです。

=== トランザクション出力と資産の価値

トランザクションが連なることで所有権を移転していく資産の価値。
ということは、最後に所有権を持っている人が、その資産の持ち主というわけです。

最後に所有権を持っている、ということはつまり、
まだどこにも接続されていないトランザクション出力のこととなります。

この、「どこにも接続されていないトランザクション出力」のことを、
Unspent Transaction Output、略して UTXO と呼びます。

この UTXO を全部かき集めたものが、その人が持つ資産の残高、となります。

注意したいのは、トランザクション自体に持ち主は存在しない。というところです。
トランザクションはあくまで資産の価値の所有権移転の情報を持っているだけであり、
誰のものでもありません。ただの公開情報でしかありません。
資産の価値はトランザクション自体ではなく、その出力にあるというのがポイントです。

UTXO を使用して別のトランザクションを接続することで、
その資産を使うことになり、新たな UTXO を手に入れるのが、
資産の入手というわけです。

=== トランザクションを接続する仕組み

トランザクションの出力と、別のトランザクションの入力を接続する。
これで所有権の移転が行われるとすると、誰でも接続できては困ります。

そこで、トランザクションの出力は通常ロックされています。

ロックされていると言っても、状態を持つわけではありません
（ブロックチェーンではデータの書き換えができないことに注意）。
トランザクションの出力には、ロックを解除するための条件が書かれています。
これを、scriptPubKey と呼んでいます。

そして、トランザクションの入力には、その条件を満たすデータ列を書きます。
これを scriptSig と呼んでいます。

あるトランザクションの出力に書かれた scriptPubKey、これに対応する
scriptSig を持つ入力を作成することができれば、その UTXO の所有者であることを
証明できる。そういうカラクリを用意します。

今までふわっと所有権と呼んできましたが、UTXO に書かれた scriptPubKey に、
対応する scriptSig を作成できることが、UTXO を所有している、ということであり、
つまり暗号資産を所有している、と呼べるわけです。

=== scriptPubKey と scriptSig

script という単語で勘付いた方も多いと思いますが、実はこの 2 つのデータ列は、
Script と呼ばれる言語で書かれたプログラムとなっています。

この言語はスタック型の言語となっており、bitcoin にはその機械語を
実行する仮想マシンが実装されています。

bitcoin は、scriptSig と scriptPubKey を連結して 1 つのプログラムとした後、
それを実行します。そして、実行が成功して、スタックトップに TRUE が積まれていた場合、
それをアンロック成功とみなして接続を行います。

ここで実行が失敗した場合や、スタックトップが FALSE だった場合、
bitcoin はその scriptSig は不正なものとみなして、トランザクションごとドロップさせます。

例えば、scriptPubKey に
//list[EQUAL][サンプル scriptPubKey]{
1. OP_PUSH 0x1234
2. OP_EQUAL
//}
と書かれていた場合、この UTXO をアンロックできる scriptSig は
//list[PUSH][サンプル scriptSig]{
1. OP_PUSH 0x1234
//}
となります。

OP_PUSH はスタックに後続の値を積む命令で、OP_EQUAL はスタックトップの 2 つの値を
比較して、一致していれば TRUE、一致していなければ FALSE を積む命令です。

この 2 つの Script プログラムを連結して 1 つにすると
//list[MERGED][サンプル Script]{
1. OP_PUSH 0x1234
2. OP_PUSH 0x1234
3. OP_EQUAL
//}
となり、実行すると無事にスタックトップに TRUE が積まれます。

ここで、scriptSig で PUSH する値が 0x1234 でなかった場合、
OP_EQUAL は FALSE を積むので、接続はできません。

これが、UTXO のロック・アンロックの仕組みとなります。

=== 古典的な Script、P2PK

scriptPubKey と scriptSig には Script 言語で記述できるプログラムならば
どんなものでも書けます。なので、みんな自由に作って構いませんが、
一般的に使われている Script のパターンというものがあります。

というか、そもそもの目的として、「scriptPubKey に対応する scriptSig を
作成できることを持って、所有者である証明とする」というところからして、
暗号的に十分安全なプログラムを作らなければなりません。

まずは古典的なもので、P2PK (pay-to-pubkey) があります。

//list[P2PK][P2PK]{
scriptSig:
1. OP_PUSH <電子署名>
scriptPubKey:
1. OP_PUSH <公開鍵>
2. OP_CHECKSIG
//}

OP_CHECKSIG は、スタックの先頭に積んである 2 つの値を、
公開鍵と電子署名として扱い、ECDSA（楕円曲線 DSA）の署名検証を行う命令です。
バリエーションとして、署名検証に失敗したら即実行を中断する OP_CHECKSIGVERIFY を
使用する場合もあります。

scriptSig、scriptPubKey の名前の由来もわかっていただけたのではないでしょうか。

=== scriptPubKey と UTXO set

bitcoin のノードは、新規のトランザクションを通知されたとき、
そのトランザクションが正式なものか検証を行います。

二重使用といって、同じ出力を 2 つのトランザクションの入力として使うことは禁止されているため、
UTXO set と呼ばれる、UTXO をリストアップしたデータベースを持っています。
このデータベースの肥大化を防ぐため、UTXO の一部である scriptPubKey は極力小さくしたい。
という要望があります。

今回はこの要望を満たそうと試みているところが根幹にあります。

=== scriptPubKey を小さくする P2PKH

ECDSA の公開鍵はそれなりに大きいです。

bitcoin の使用する ECDSA は、secp256k1 という楕円曲線を使用しているため、
公開鍵は compressed 形式というフォーマットで書いても 33Byte になります。

そこで、以下の Script が考案されました。
現在でも一般的に使われている P2PKH (pay-to-pubkey-hash) です。

//list[P2PKH][P2PKH]{
scriptSig:
1. OP_PUSH <電子署名>
2. OP_PUSH <公開鍵>
scriptPubKey:
1. OP_DUP
2. OP_HASH160
3. OP_PUSH <公開鍵のハッシュ>
4. OP_EQUALVERIRFY
5. OP_CHECKSIG
//}

OP_HASH160 は、スタックトップの SHA-256 ハッシュを計算してから、
RIPEMD-160 ハッシュを計算する命令です。
OP_EQUALVERIFY はスタックトップの 2 要素を比較して、不一致ならば
実行を即時失敗させる命令です。

scriptPubKey の命令数自体は増えていますが、いずれも 1Byte の命令ですので、
公開鍵のハッシュが 160bit = 20Byte と考えれば、25Byte とそれなりに縮小できました。

また、この形式にはもう 1 つメリットがあります。

scriptPubKey に書くのが公開鍵ではなく、公開鍵のハッシュ値で済む、ということです。
つまり、誰かに送金するとき、相手の公開鍵ではなく公開鍵のハッシュを教えてもらえば済みます。
この手続きでやり取りするデータ量が小さくなるというものです。

そこで、この公開鍵のハッシュを Base58 エンコードしたものでやり取りすれば便利だね？というわけで、
それをコインアドレスと呼んでいます。未だによく使われていますね。

=== scriptPubKey のおばけ、マルチシグ

マルチシグという言葉はご存じでしょうか？

scriptPubKey に複数の公開鍵を書いておいて、
それに対応する電子署名が何個か以上あれば検証成功とする機能です。

例えば、以下の例を見てみましょう。

//list[MSIG][MULTI-SIG]{
scriptSig:
1. OP_PUSH 0
2. OP_PUSH <電子署名１>
3. OP_PUSH <電子署名２>
scriptPubKey:
1. OP_PUSH 2
2. OP_PUSH <公開鍵１>
3. OP_PUSH <公開鍵２>
4. OP_PUSH <公開鍵３>
5. OP_PUSH 3
6. OP_CHECKMULTISIG
//}

scriptPubKey には 3 つの公開鍵を書いておき、
そのうち 2 つの電子署名があれば接続していいよ、というスクリプトです。
OP_CHECKMULTISIG はそんな感じでうまく動く命令です。

scriptSig はちょっと注意が必要で、OP_CHECKMULTISIG の実装にバグがあるので、
先頭にダミーのデータを PUSH する必要があります。
これは bitcoin 当初にあったバグで、未だに引きずっています。酷い……

さて、ここで思い出してください。UTXO set の肥大化を抑えたいので、
scriptPubKey は小さくしたい。ところがどうでしょう。
この scriptPubKey は 1 つで 33Byte ある公開鍵のおばけです。

これをなんとかしたい、というわけで今回のお話が始まります。
